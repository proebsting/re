/*
	rxcluster.go -- cluster regular expressions

	usage:  rxcluster [options] [exprfile]

	-t nnn	set clustering threshold as a percentage of successes
	-n nnn	set number of examples generated for each regexp
	-r nnn	set maximum replication factor for example generation
	-i nnn	initialize random seed for reproducible results
	-g	print grids showing how examples matched up
	-s	print singleton clusters for completeness
	-v	enable verbose commentary

	Rxcluster reads a file of regular expressions and groups them into
	clusters.  Grouping is based on matching a shared set of examples.

	Two expressions are clustered together if each accepts a certain
	percentage of examples randomly generated by the other expression.
	Both expressions must pass the threshold, but because grouping is
	transitive, clusters can potentially contain expressions that are
	only distantly related.

	Each cluster is printed with its internal index, a "best" example,
	and the number of patterns actually matched by that example out of
	the total expression count.  (The best is example matches the most
	expressions, with longer length as a tiebreaker.)
	This is followed by the expressions composing the cluster.
	By default, singleton clusters do not print.

	The Monte-Carlo effects of random example generation can cause
	clustering to vary from one run to another for the same input.

	spring 2014 / gmt
*/
package main

import (
	"flag"
	"fmt"
	"log"
	"math/rand"
	"rx"
	"time"
)

//  global options from command line
var verbose bool   // verbosity flag
var singles bool   // show singletons, too
var showgrids bool // show grids of examples with clusters
var nexamples int  // number of examples for each regexp
var threshold int  // threshold percentage
var maxdist int    // maximum distance derived from threshold
var maxrepl int    // maximum replication in examples
var args []string  // positional arguments

// other globals
var exprs []*RegEx // list of expressions
var nclusters int  // current number of clusters

const labelchars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

//  a RegEx struct holds everything we need per input expression
type RegEx struct {
	index          uint     // expression index
	cnum           uint     // cluster containing this expr
	next           *RegEx   // next member in this cluster
	label          byte     // label char within cluster
	rx.RegExParsed          // Expr, Tree, Err, Meta
	dfa            *rx.DFA  // matching automaton
	examples       []string // generated examples
}

//  main control
func main() {
	filename := cmdline()  // process command line
	exprs = load(filename) // load expressions
	nclusters = len(exprs)
	for i := 0; i < len(exprs); i++ {
		for j := 0; j < i; j++ {
			if distance(i, j) <= maxdist { // if close enough
				merge(i, j) // combine into cluster
			}
		}
	}
	fmt.Printf("%d expression(s) in %d cluster(s) using %d%% threshold\n",
		len(exprs), nclusters, threshold)
	if e := rx.InputErrorCount; e > 0 {
		fmt.Printf("(%d erroneous expression(s) ignored)\n", e)
	}
	for i := 0; i < len(exprs); i++ {
		if exprs[i].cnum == uint(i) { // if the head of a cluster
			showcluster(i) // show the cluster
		}
	}
}

//  validate and process command line arguments, returning input filename
func cmdline() string {

	t := flag.Int("t", 50, "clustering threshold percentage")
	n := flag.Int("n", 10, "number of examples per regex")
	r := flag.Int("r", 5, "maximum replication in examples")
	i := flag.Int("i", 0, "random seed")
	g := flag.Bool("g", false, "show grids with clusters")
	s := flag.Bool("s", false, "show singletons too")
	v := flag.Bool("v", false, "verbose commentary")
	flag.Parse()
	threshold = *t
	nexamples = *n
	maxrepl = *r
	showgrids = *g
	verbose = *v
	singles = *s
	maxdist = ((100 - threshold) * *n) / 100

	if *n < 1 {
		log.Fatal("at least one example required")
	}
	if *t < 1 || *t > 99 {
		log.Fatal("threshold must be between 0 and 100 percent")
	}

	if *i == 0 {
		*i = 1 + time.Now().Nanosecond()%9998
	}
	rand.Seed(int64(*i))
	if verbose {
		fmt.Printf("rxcluster -t %d -n %d -r %d -i %d => d=%d\n",
			*t, *n, *r, *i, maxdist)
	}

	args := flag.Args()
	if len(args) > 1 {
		log.Fatal("single filename required")
		return "" //NOTREACHED
	} else if len(args) == 1 {
		return args[0] // return filename
	} else {
		return "-" // read from stdin
	}
}

//  load expressions, returning list and augmented parse tree list
func load(filename string) []*RegEx {
	elist := make([]*RegEx, 0) // expression structure list
	rx.LoadExpressions(filename, func(l *rx.RegExParsed) {
		if l.Tree != nil { // if a real expression
			e := &RegEx{}
			e.index = uint(len(elist))
			e.cnum = uint(len(elist))
			e.RegExParsed = *l         // save parse tree
			e.examples = genex(l.Tree) // gen examples unaugmented
			t := rx.Augment(l.Tree, e.index)
			e.dfa = rx.BuildDFA(t) // build DFA
			if verbose {
				fmt.Println()
				showexpr(e)     // show details of expr
				showexamples(e) // show its examples
			}
			elist = append(elist, e)
		}
	})
	if verbose {
		fmt.Printf("\nloaded %d expression(s), ignored %d more\n",
			rx.InputRegExCount, rx.InputErrorCount)
	}
	return elist
}

//  generate examples from a parse tree
func genex(tree rx.Node) []string {
	x := make([]string, 0)
	for i := 0; i < nexamples; i++ {
		r := maxrepl - i%maxrepl
		x = append(x, string(tree.Example(make([]byte, 0), r)))
	}
	return x
}

//  calculate distance between expressions i and j
//  as max number of examples rejected by the other
//  (quitting early as soon as result exceeds maxdist)
func distance(i int, j int) int {
	dij := 0
	dji := 0
	for k := 0; k < nexamples; k++ {
		if exprs[i].dfa.Accepts(exprs[j].examples[k]) == nil {
			dij++
			if dij > maxdist {
				return dij
			}
		}
		if exprs[j].dfa.Accepts(exprs[i].examples[k]) == nil {
			dji++
			if dji > maxdist {
				return dji
			}
		}
	}
	if dij > dji {
		return dij
	} else {
		return dji
	}
}

//  merge two exprs into the same cluster (dragging along associated members).
func merge(i int, j int) {
	if exprs[i].cnum == exprs[j].cnum {
		return // already in same cluster (including i==j case)
	}
	//  Invariant: For cluster n, expr[n] is the head of the chain.
	//  Find the head of j's cluster, change every cnum to i's cnum,
	//  and link j's chain immediately after i (the head of cluster n).
	n := exprs[i].cnum
	jhead := exprs[exprs[j].cnum]
	x := jhead
	xlast := x
	for x != nil {
		x.cnum = n
		xlast = x
		x = x.next
	}
	xlast.next = exprs[n].next
	exprs[n].next = jhead
	nclusters-- // decrement global cluster count
}

//  show cluster contents
func showcluster(cnum int) {
	m := 0
	for x := exprs[cnum]; x != nil; x = x.next {
		x.label = labelchars[m%len(labelchars)]
		m++ // count expressions in cluster
	}
	if m > 1 || singles {
		s, n := bestex(cnum)
		fmt.Printf("\ncluster %d:  \"%s\" (%d/%d)\n", cnum, s, n, m)
		for x := exprs[cnum]; x != nil; x = x.next {
			showexpr(x)
			if m > 1 && showgrids {
				showgrid(cnum, x)
			}
		}
	}
}

//  show details of one expression
func showexpr(e *RegEx) {
	if e.label != 0 && showgrids {
		fmt.Printf("%c: ", e.label)
	}
	fmt.Printf("%d. %s\n", e.index, e.Expr) // print regex
}

//  show examples for one expression
func showexamples(e *RegEx) {
	if verbose { // print examples if verbose
		for _, s := range e.examples {
			fmt.Print("  ", s)
		}
		fmt.Println()
	}
}

// return count of accepting expressions in cluster
func checkall(cnum int, s string) int {
	n := 0
	for x := exprs[cnum]; x != nil; x = x.next {
		if x.dfa.Accepts(s) != nil {
			n++
		}
	}
	return n
}

//  return best cluster example and number of exprs matched
func bestex(cnum int) (string, int) {
	newscore := 0
	bestscore := 0
	beststring := ""
	for x := exprs[cnum]; x != nil; x = x.next {
		for _, s := range x.examples {
			n := checkall(cnum, s)
			newscore = 10000*n + len(s)
			if newscore > bestscore {
				bestscore = newscore
				beststring = s
			}
		}
	}
	return beststring, bestscore / 10000
}

//  show result grid for one cluster
func showgrid(cnum int, x *RegEx) {
	for i := 0; i < nexamples; i++ {
		fmt.Printf("   ")
		ex := x.examples[i]
		for y := exprs[cnum]; y != nil; y = y.next {
			if y.dfa.Accepts(ex) != nil {
				fmt.Printf("%c", y.label)
			} else {
				fmt.Printf("-")
			}
		}
		fmt.Printf("  %s\n", ex)
	}
}
